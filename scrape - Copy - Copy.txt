from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.firefox.service import Service as FirefoxService
from webdriver_manager.firefox import GeckoDriverManager
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import StaleElementReferenceException
import time

# Setup GeckoDriver
service = FirefoxService(executable_path=GeckoDriverManager().install())
driver = webdriver.Firefox(service=service)

# Open the Looker Studio report
url = 'https://lookerstudio.google.com/reporting/c7175b01-3602-41d5-9c31-31bfcbfcc574/page/p_0dc9nmnl8c'
driver.get(url)
time.sleep(5)  # Wait for the page to load

# Wait for the table container to be present
wait = WebDriverWait(driver, 5)
wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, '.tableBody')))
table_body = driver.find_element(By.CSS_SELECTOR, '.tableBody')

# Find the table element using the provided CSS selector
scroll_container = driver.find_element(By.CSS_SELECTOR, '.centerColsContainer')

# Function to extract rows data
def extract_rows():
    rows_data = []
    rows = table_body.find_elements(By.CSS_SELECTOR, '.row')
    for row in rows:
        try:
            cells = row.find_elements(By.CLASS_NAME, 'cell')
            row_data = [cell.text for cell in cells]
            rows_data.append(row_data)
        except StaleElementReferenceException:
            continue  # Handle stale element references gracefully
    return rows_data

# Scroll and load all data
all_rows_data = set()

# Define the number of scrolls and the scroll increment
num_scrolls = 6  # You can adjust this number based on your needs
scroll_increment = 500  # Pixels to scroll on each iteration

for _ in range(num_scrolls):
    new_rows_data = extract_rows()
    for data in new_rows_data:
        all_rows_data.add(tuple(data))  # Add as tuple to allow set usage

    # Scroll within the table element
    driver.execute_script('arguments[0].scrollTop += {}'.format(scroll_increment), scroll_container)
    time.sleep(2)  # Shorter wait time between scrolls

# Convert the set of tuples back to a list of lists for further processing if needed
unique_rows_data = [list(row) for row in all_rows_data]

# Close the driver
driver.quit()

# Optionally convert to DataFrame
import pandas as pd
df = pd.DataFrame(unique_rows_data, columns=['Column1', 'Column2', 'Column3'])  # Update columns as needed
print(df.head())